"use strict";
// Every commented-out export is re-exported by another file...
exports.__esModule = true;
var fp_ts_1 = require("fp-ts");
exports.Alt = fp_ts_1.alt;
exports.Alternative = fp_ts_1.alternative;
exports.Applicative = fp_ts_1.applicative;
exports.Apply = fp_ts_1.apply;
// array as Array,
exports.Bifunctor = fp_ts_1.bifunctor;
exports.BooleanAlgebra = fp_ts_1.booleanAlgebra;
exports.Bounded = fp_ts_1.bounded;
exports.BoundedDistributiveLattice = fp_ts_1.boundedDistributiveLattice;
exports.BoundedJoinSemilattice = fp_ts_1.boundedJoinSemilattice;
exports.BoundedLattice = fp_ts_1.boundedLattice;
exports.BoundedMeetSemilattice = fp_ts_1.boundedMeetSemilattice;
exports.Category = fp_ts_1.category;
exports.Chain = fp_ts_1.chain;
exports.ChainRec = fp_ts_1.chainRec;
exports.Choice = fp_ts_1.choice;
exports.Comonad = fp_ts_1.comonad;
exports.Console = fp_ts_1.console;
exports.Const = fp_ts_1["const"];
exports.Contravariant = fp_ts_1.contravariant;
exports.Date = fp_ts_1.date;
exports.DistributiveLattice = fp_ts_1.distributiveLattice;
// either as Either,
exports.EitherT = fp_ts_1.eitherT;
// exception as Exception,
exports.Extend = fp_ts_1.extend;
exports.Field = fp_ts_1.field;
exports.Filterable = fp_ts_1.filterable;
exports.FilterableWithIndex = fp_ts_1.filterableWithIndex;
exports.Foldable = fp_ts_1.foldable;
exports.Foldable2v = fp_ts_1.foldable2v;
exports.FoldableWithIndex = fp_ts_1.foldableWithIndex;
exports.Free = fp_ts_1.free;
exports.FreeGroup = fp_ts_1.freeGroup;
exports.Fn = fp_ts_1["function"];
exports.Functor = fp_ts_1.functor;
exports.FunctorWithIndex = fp_ts_1.functorWithIndex;
exports.Group = fp_ts_1.group;
exports.HeytingAlgebra = fp_ts_1.heytingAlgebra;
exports.HKT = fp_ts_1.hkt;
// identity as Identity,
exports.Invariant = fp_ts_1.invariant;
exports.IO = fp_ts_1.io;
exports.IOEither = fp_ts_1.ioEither;
exports.IORef = fp_ts_1.ioRef;
exports.IxIO = fp_ts_1.ixIO;
exports.IxMonad = fp_ts_1.ixMonad;
exports.JoinSemilattice = fp_ts_1.joinSemilattice;
exports.Lattice = fp_ts_1.lattice;
exports.Map = fp_ts_1.map;
exports.MeetSemilattice = fp_ts_1.meetSemilattice;
exports.Monad = fp_ts_1.monad;
exports.MonadIO = fp_ts_1.monadIO;
exports.MonadTask = fp_ts_1.monadTask;
exports.Monoid = fp_ts_1.monoid;
exports.Monoidal = fp_ts_1.monoidal;
exports.NonEmptyArray = fp_ts_1.nonEmptyArray;
// option as Option,
exports.OptionT = fp_ts_1.optionT;
exports.Ord = fp_ts_1.ord;
exports.Ordering = fp_ts_1.ordering;
exports.Pair = fp_ts_1.pair;
exports.Plus = fp_ts_1.plus;
exports.Profunctor = fp_ts_1.profunctor;
exports.Random = fp_ts_1.random;
exports.Reader = fp_ts_1.reader;
exports.ReaderT = fp_ts_1.readerT;
exports.ReaderTaskEither = fp_ts_1.readerTaskEither;
exports.Record = fp_ts_1.record;
exports.Ring = fp_ts_1.ring;
exports.Semigroup = fp_ts_1.semigroup;
exports.Semigroupoid = fp_ts_1.semigroupoid;
exports.Semiring = fp_ts_1.semiring;
exports.Set = fp_ts_1.set;
exports.Setoid = fp_ts_1.setoid;
exports.State = fp_ts_1.state;
exports.StateT = fp_ts_1.stateT;
exports.Store = fp_ts_1.store;
exports.StrMap = fp_ts_1.strmap;
exports.Strong = fp_ts_1.strong;
exports.Task = fp_ts_1.task;
// taskEither as TaskEither,
// these as These,
exports.Trace = fp_ts_1.trace;
exports.Traversable = fp_ts_1.traversable;
exports.Traversable2v = fp_ts_1.traversable2v;
exports.TraversableWithIndex = fp_ts_1.traversableWithIndex;
exports.Tree = fp_ts_1.tree;
exports.Tuple = fp_ts_1.tuple;
exports.Unfoldable = fp_ts_1.unfoldable;
exports.Validation = fp_ts_1.validation;
exports.Writer = fp_ts_1.writer;
exports.Compactable = fp_ts_1.compactable;
exports.Witherable = fp_ts_1.witherable;
exports.Zipper = fp_ts_1.zipper;
